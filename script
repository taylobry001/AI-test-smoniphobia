import tkinter as tk
import random
from collections import deque

GRID_SIZE = 12  # Room made larger
CELL_SIZE = 40
WINDOW_SIZE = GRID_SIZE * CELL_SIZE

class Game:
    def __init__(self, root):
        self.root = root
        self.root.title("Shadow Stalker 2026")
        self.canvas = tk.Canvas(self.root, width=WINDOW_SIZE, height=WINDOW_SIZE, bg="black")
        self.canvas.pack()

        self.monster = None
        self.player = None
        self.flashlight_ui = None
        self.walls = set()
        self.door_pos = None
        self.door_locked = False
        self.flashlight_on = False
        self.aggression = random.randint(5, 20)
        
        self.root.bind("<l>", self.toggle_door); self.root.bind("<L>", self.toggle_door)
        self.root.bind("<f>", self.toggle_flashlight); self.root.bind("<F>", self.toggle_flashlight)

        self.reset_simulation()

    def reset_simulation(self):
        self.canvas.delete("all")
        self.walls.clear()
        self.door_locked = False
        self.flashlight_on = False
        self.draw_grid()
        self.create_room_around_player()
        self.spawn_player()
        self.spawn_monster()
        
        self.status_text = self.canvas.create_text(10, 10, anchor="nw", text="STATUS: IDLE", fill="yellow", font=("Arial", 10, "bold"))
        self.aggr_text = self.canvas.create_text(10, 25, anchor="nw", text=f"AGGR: {self.aggression}", fill="orange", font=("Arial", 10, "bold"))
        self.move_monster()

    def toggle_flashlight(self, event):
        self.flashlight_on = not self.flashlight_on
        if self.flashlight_on:
            px, py = self.canvas.coords(self.player)[:2]
            self.flashlight_ui = self.canvas.create_oval(px-60, py-60, px+100, py+100, outline="white", width=2, tags="light")
        else:
            self.canvas.delete("light")

    def toggle_door(self, event):
        if not self.door_pos: return
        self.door_locked = not self.door_locked
        if self.door_locked:
            self.walls.add(self.door_pos)
            self.door_indicator = self.canvas.create_rectangle(self.door_pos[0], self.door_pos[1], self.door_pos[0]+CELL_SIZE, self.door_pos[1]+CELL_SIZE, fill="red", tags="lock")
        else:
            self.walls.discard(self.door_pos)
            self.canvas.delete("lock")

    def create_room_around_player(self):
        mid = GRID_SIZE // 2
        walls_pos = []
        corners = [((mid-2)*CELL_SIZE, (mid-2)*CELL_SIZE), ((mid+2)*CELL_SIZE, (mid-2)*CELL_SIZE),
                   ((mid-2)*CELL_SIZE, (mid+2)*CELL_SIZE), ((mid+2)*CELL_SIZE, (mid+2)*CELL_SIZE)]
        for x in range(mid-2, mid+3):
            for y in range(mid-2, mid+3):
                if x == mid-2 or x == mid+2 or y == mid-2 or y == mid+2:
                    walls_pos.append((x * CELL_SIZE, y * CELL_SIZE))
        
        possible_doors = [p for p in walls_pos if p not in corners]
        self.door_pos = random.choice(possible_doors)
        for pos in walls_pos:
            if pos != self.door_pos:
                self.canvas.create_rectangle(pos[0], pos[1], pos[0]+CELL_SIZE, pos[1]+CELL_SIZE, fill="#444", outline="white")
                self.walls.add(pos)

    def spawn_player(self):
        c = (GRID_SIZE // 2) * CELL_SIZE
        self.player = self.canvas.create_rectangle(c, c, c+CELL_SIZE, c+CELL_SIZE, fill="cyan", outline="white")

    def spawn_monster(self):
        self.monster = self.canvas.create_rectangle(0, 0, CELL_SIZE, CELL_SIZE, fill="red", outline="black")

    def get_path(self, start, target):
        queue = deque([(start, [])])
        visited = {start}
        while queue:
            (cx, cy), path = queue.popleft()
            if (cx, cy) == target: return path
            for dx, dy in [(0,-CELL_SIZE),(0,CELL_SIZE),(-CELL_SIZE,0),(CELL_SIZE,0)]:
                nxt = (cx+dx, cy+dy)
                if (0 <= nxt[0] < WINDOW_SIZE and 0 <= nxt[1] < WINDOW_SIZE and nxt not in self.walls and nxt not in visited):
                    visited.add(nxt); queue.append((nxt, path + [nxt]))
        return None

    def draw_grid(self):
        for i in range(0, WINDOW_SIZE+1, CELL_SIZE):
            self.canvas.create_line(i, 0, i, WINDOW_SIZE, fill="#111")
            self.canvas.create_line(0, i, WINDOW_SIZE, i, fill="#111")

    def move_monster(self):
        if not self.monster: return
        m_coords = self.canvas.coords(self.monster)
        p_coords = self.canvas.coords(self.player)
        m_pos, p_pos = tuple(m_coords[:2]), tuple(p_coords[:2])

        # Shadow Mechanic: Teleport nearby (3 blocks away or inside room)
        if random.random() < 0.05: # 5% chance to teleport as a Shadow
            side = random.choice([-CELL_SIZE, CELL_SIZE])
            self.canvas.coords(self.monster, p_pos[0]+side, p_pos[1], p_pos[0]+side+CELL_SIZE, p_pos[1]+CELL_SIZE)
            self.canvas.itemconfig(self.monster, fill="#111") # Dark shadow form
            self.canvas.itemconfig(self.status_text, text="STATUS: SHADOW STALKING", fill="purple")
        
        # Flashlight Check: If flashlight is ON and touching shadow, banish it
        if self.flashlight_on and self.canvas.itemconfig(self.monster)['fill'][-1] == "#111":
            m_c = self.canvas.coords(self.monster)
            if abs(m_c[0]-p_coords[0]) <= CELL_SIZE and abs(m_c[1]-p_coords[1]) <= CELL_SIZE:
                self.canvas.itemconfig(self.monster, fill="red")
                self.canvas.coords(self.monster, 0, 0, CELL_SIZE, CELL_SIZE) # Reset to start
                self.canvas.itemconfig(self.status_text, text="STATUS: BANISHED!", fill="white")

        path = self.get_path(tuple(self.canvas.coords(self.monster)[:2]), p_pos)
        if path and self.canvas.itemconfig(self.monster)['fill'][-1] == "red":
            self.canvas.itemconfig(self.status_text, text="STATUS: HUNTING", fill="lime")
            ns = path[0]
            self.canvas.coords(self.monster, ns[0], ns[1], ns[0]+CELL_SIZE, ns[1]+CELL_SIZE)
        
        if self.canvas.coords(self.monster) == p_coords:
            self.canvas.itemconfig(self.status_text, text="STATUS: KILLED PLAYER", fill="red")
            self.root.after(1000, self.reset_simulation); return

        delay = max(50, 600 - (self.aggression * 25))
        self.root.after(delay, self.move_monster)

if __name__ == "__main__":
    window = tk.Tk(); game = Game(window); window.mainloop()
